# Go gRPC Services

An obvious application of gRPC is to implement a network service in Go. To accomplish this, we can use the `prototool` command to help create .proto files and generate a Go client and server interfaces, and the `google.golang.org/grpc` package to implement a server. There's a lot more to learn about a service oriented architecture, but the promise of gRPC is that we can rapidly build strongly typed client and servers. So lets jump straight to our Go service.

## Defining a Service, Methods and Messages in a .proto File

First we create a `.proto` file in the proper path and "proto3" headers. The `prototool` command, configured with a `prototool.yaml` creates this for us.

```yaml
protoc:
  version: 3.6.1

create:
  packages:
    - directory: protos
      name: omgrpc
```
> From prototool.yaml

```shell
$ mkdir -p protos/users/v1/
$ prototool create protos/users/v1/users.proto
```

Then we add `service`, `rpc` and `message` definitions for our service:

```proto
syntax = "proto3";

package omgrpc.users.v1;

option go_package = "v1pb";
option java_multiple_files = true;
option java_outer_classname = "UsersProto";
option java_package = "com.omgrpc.users.v1";

import "google/protobuf/timestamp.proto";

service Users {
  rpc Get(GetRequest) returns (User);
  rpc Create(CreateRequest) returns (User);
}

message User {
  string id = 1;
  string parent = 2;
  string name = 3;
  string display_name = 4;
  google.protobuf.Timestamp create_time = 5;
}

message GetRequest {
  string name = 1;
}

message CreateRequest {
  string parent = 1;
  User user = 2;
}
```
> From protos/users/v1/users.proto

Now we can use `prototool` to validate and format our file:

```shell
$ prototool all
protos/users/v1/users.proto:14:14:"CreateRequest" is not defined.

$ prototool all
$ echo $?
0
```

## Generating a Server Interfaces

Next we create a `.go` file with a gRPC server interface. The `prototool generate` command, configured with a `prototool.yaml` creates this for us by invoking the `protoc` compiler with proper flags.

```yaml
generate:
  go_options:
    import_path: github.com/nzoschke/omgrpc/protos

  plugins:
    - name: go
      type: go
      output: gen/go
      flags: plugins=grpc
```
> From prototool.yaml

```shell
$ prototool generate
```

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: protos/users/v1/users.proto

package v1pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

type User struct {
	Id                   string               `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Parent               string               `protobuf:"bytes,2,opt,name=parent,proto3" json:"parent,omitempty"`
	Name                 string               `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	DisplayName          string               `protobuf:"bytes,4,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	CreateTime           *timestamp.Timestamp `protobuf:"bytes,5,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

// UsersServer is the server API for Users service.
type UsersServer interface {
	Get(context.Context, *GetRequest) (*User, error)
	Create(context.Context, *CreateRequest) (*User, error)
}
```
> From gen/go/protos/users/v1/users.pb.go

There's a lot more generated code in this file, but we can see how the .proto definition results in strongly typed Go structs, client, and server methods.

## Implementing the Server

Now we can implement the server. We import the generated Go package, implement the `Create` and `Get` server methods, and use the `google.golang.org/grpc` package to register and serve the server.

```go
package main

import (
	"context"
	"fmt"
	"net"

	"github.com/satori/go.uuid"

	"github.com/golang/protobuf/ptypes"
	users "github.com/nzoschke/omgrpc/gen/go/protos/users/v1"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func main() {
	if err := serve(); err != nil {
		panic(err)
	}
}

func serve() error {
	s := grpc.NewServer()
	users.RegisterUsersServer(s, &Server{})

	l, err := net.Listen("tcp", "0.0.0.0:8000")
	if err != nil {
		return err
	}

	fmt.Println("listening on :8000")
	return s.Serve(l)
}

// Server implements the users/v1 interface
type Server struct{}

// Create creates a User
func (s *Server) Create(ctx context.Context, u *users.CreateRequest) (*users.User, error) {
	return &users.User{
		CreateTime:  ptypes.TimestampNow(),
		DisplayName: u.User.DisplayName,
		Id:          uuid.Must(uuid.NewV1()).String(),
		Name:        u.User.Name,
		Parent:      u.Parent,
	}, nil
}

// Get returns a User or NotFound error
func (s *Server) Get(ctx context.Context, u *users.GetRequest) (*users.User, error) {
	return nil, status.Errorf(codes.NotFound, "%s not found", u.Name)
}
```
> from cmd/users-v1/main.go

Note that for this example we're not persisting any User data.

## Testing

Finally we can test our service. We run the server program, then use the `prototool grpc` command to translate JSON <-> gRPC requests and responses:

```shell
$ go run cmd/users-v1/main.go
listening on :8000

$ prototool grpc                      \
--address 0.0.0.0:8000                \
--method omgrpc.users.v1.Users/Create \
--data '{
    "parent": "teams/myteam",
    "user": {
      "name": "grpc",
      "displayName": "Grace P Clark"
    }
  }'
```

```json
{
  "id": "e7b1f9dc-d2f0-11e8-9da0-8c859038fc73",
  "parent": "teams/myteam",
  "name": "grpc",
  "displayName": "Grace P Clark",
  "createTime": "2018-10-18T16:14:35.598484Z"
}
```

```shell
$ prototool grpc                    \
--address 0.0.0.0:8000              \
--method omgrpc.users.v1.Users/Get  \
--data '{"name": "foo"}'

rpc error: code = NotFound desc =  not found
```

## Summary

Building a gRPC service with Go is fast and easy. We just have to:

- Define the service, methods and messages in a .proto file
- Generate a Go server interface
- Implement the server logic

We no longer have to worry about:

* HTTP server semantics
* Weak type conversions
* JSON encoding / decoding

Go, gRPC, and `prototool` make building network services easy.
